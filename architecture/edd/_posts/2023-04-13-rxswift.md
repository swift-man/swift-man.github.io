---
sidebar:
  title: "Architecture"
  nav: sidebar-architecture
  icon: "fas fa-sitemap"
title: "[iOS] RxSwift"
toc: true
toc_sticky: true
toc_label: 목차
tag: "EDD"
depth:
  - title: "Architecture"
    url: /architecture/
    icon: "fas fa-sitemap"
  - title: "EDD"
    url: /architecture/edd/
    icon: "far fa-folder-open"
---
# Trait
## Maybe
* Single과 Completable의 중간
* Completed, Element, Error 중 1개만 발행

## ControlEvent
* UI를 위한 ObservableType
* 실패하지 않음
* ControlProperty가 Subscribe 할때 1개의 이벤트를 주는것과 반대로 한개도 주지 않음(이벤트니까)
* Control이 Dealloc되기 시작할때 Completed 발생
* 이벤트는 MainScheduler로 전달
* 이벤트 발생은 ConcurrentMainScheduler에서 생성

```swift
scrollView.rx.willBeginDragging
button.rx.tap
```

## ControlProperty
* UI를 위한 ObservableType(이면서 ObserverType)
* 실패하지 않음
* shared(replay: 1) behavior
  * subscribe되면 즉시 마지막 element를 반환해줌
* control이 dealloc되기 시작할때 Completed 발생
* MainScheduler 에서 발생
* SubscribeOn, ObserveOn 모두 Main

```swift
label.rx.text
```

* label.rx.isHidden은 ControlProperty가 아님(binder)

## Driver
* UI관련된 것을 다루는데 좋음
* Error가 없다.
* MainScheduler 작동

```swift
.observe(on: MainScheduler.instance)
  .catchErrorJustReturn(onErrorJustReturn)
  .share(replay: 1, scope: .whileConnected)
```
* drive 함수로 이벤트 처리

```swift
let publishSubject = PublishSubject<Int>()
let driver = pulishSubject.asDriver(onErrorJustReturn: 100)
driver.drive(onNext: { element in
  print("drive1: \(element)")
})
.dispose(by: disposeBag)

publishSubject.onNext(4)

driver.drive(onNext: { element in
  print("drive2: \(element)")
})
.dispose(by: disposeBag)

publishSubject.onError(RxError.noElements)
```

## Signal
* Error가 없다(catchError)
* MainScheduler 에서 동작
* share(scope: .whileConnected) 로 동작
* 새로운 subscriber에게 replay 해주지 않는다.
